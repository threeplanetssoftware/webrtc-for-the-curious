<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="What is WebRTC? #  WebRTC, short for Web Real-Time Communication, is both an API and a Protocol. The WebRTC protocol is a set of rules for two WebRTC agents to negotiate bi-directional secure real-time communication. The WebRTC API then allows developers to use the WebRTC protocol. The WebRTC API is specified only for Javascript.
A similar relationship would be HTTP and the fetch API. WebRTC the protocol would be HTTP, and WebRTC the API would be the fetch API."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="What, Why and How"><meta property="og:description" content="What is WebRTC? #  WebRTC, short for Web Real-Time Communication, is both an API and a Protocol. The WebRTC protocol is a set of rules for two WebRTC agents to negotiate bi-directional secure real-time communication. The WebRTC API then allows developers to use the WebRTC protocol. The WebRTC API is specified only for Javascript.
A similar relationship would be HTTP and the fetch API. WebRTC the protocol would be HTTP, and WebRTC the API would be the fetch API."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/01-what-why-and-how/"><meta property="article:modified_time" content="2020-09-19T03:18:31+00:00"><meta property="og:site_name" content="WebRTC for the Curious"><title>What, Why and How | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ title="What, Why and How"><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/en.search.min.0a9c82fb228958103802c198e18a5331331abc9d65109990e54aeb8ede1d19f8.js integrity="sha256-CpyC+yKJWBA4AsGY4YpTMTMavJ1lEJmQ5Urrjt4dGfg="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/01-what-why-and-how/ class=active>What, Why and How</a></li><li><a href=/docs/02-signaling/>Signaling</a></li><li><a href=/docs/03-connecting/>Connecting</a></li><li><a href=/docs/04-securing/>Securing</a></li><li><a href=/docs/05-media-communication/>Media Communication</a></li><li><a href=/docs/06-data-communication/>Data Communication</a></li><li><a href=/docs/07-applied-webrtc/>Applied WebRTC</a></li><li><a href=/docs/08-debugging/>Debugging</a></li><li><a href=/docs/09-history-of-webrtc/>History</a></li><li><a href=/docs/10-faq/>FAQ</a></li><li><a href=/docs/11-contributing/>Contributing</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>What, Why and How</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#why-should-i-learn-webrtc>Why should I learn WebRTC?</a></li><li><a href=#webrtc-protocol-is-a-collection-of-other-technologies>WebRTC Protocol is a collection of other technologies</a><ul><li><a href=#signaling-how-clients-find-each-other-in-webrtc>Signaling: How clients find each other in WebRTC</a></li><li><a href=#connecting-and-nat-traversal-with-stunturn>Connecting and NAT Traversal with STUN/TURN</a></li><li><a href=#securing-the-transport-layer-with-dtls-and-srtp>Securing the transport layer with DTLS and SRTP</a></li><li><a href=#communicating-with-peers-via-rtp-and-sctp>Communicating with peers via RTP and SCTP</a></li></ul></li><li><a href=#webrtc-a-collection-of-protocols>WebRTC, a collection of protocols</a></li><li><a href=#how-does-webrtc-the-api-work>How does WebRTC (the API) work</a><ul><li></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=what-is-webrtc>What is WebRTC?
<a class=anchor href=#what-is-webrtc>#</a></h1><p>WebRTC, short for Web Real-Time Communication, is both an API and a Protocol. The WebRTC protocol is a set of rules for two WebRTC agents to negotiate bi-directional secure real-time communication. The WebRTC API then allows developers to use the WebRTC protocol. The WebRTC API is specified only for Javascript.</p><p>A similar relationship would be HTTP and the fetch API. WebRTC the protocol would be HTTP, and WebRTC the API would be the fetch API.</p><p>The WebRTC protocol is available in other APIs/languages besides Javascript. You can find servers and domain-specific tools as well for WebRTC. All of these implementations use the WebRTC protocol so they can interact with each other.</p><h2 id=why-should-i-learn-webrtc>Why should I learn WebRTC?
<a class=anchor href=#why-should-i-learn-webrtc>#</a></h2><p>These are the things that WebRTC will give you. This list is not exhaustive but is some of the things you may appreciate during your journey. Don&rsquo;t worry if you don&rsquo;t know some of these terms yet, this book will teach them to you along the way.</p><ul><li>Open Standard</li><li>Multiple Implementations</li><li>Available in Browsers</li><li>Mandatory Encryption</li><li>NAT Traversal</li><li>Repurposed existing technology</li><li>Congestion Control</li><li>Sub-second Latency</li></ul><h2 id=webrtc-protocol-is-a-collection-of-other-technologies>WebRTC Protocol is a collection of other technologies
<a class=anchor href=#webrtc-protocol-is-a-collection-of-other-technologies>#</a></h2><p>This is a topic that takes an entire book to explain. However, to start off we break it into four steps.</p><ul><li>Signaling</li><li>Connecting</li><li>Securing</li><li>Communicating</li></ul><p>These four steps happen sequentially. The prior step must be 100% successful for the subsequent one to even begin.</p><p>One peculiar fact about WebRTC is that each step is actually made up of many other protocols! To make WebRTC we stitch together many existing technologies. In that sense, WebRTC is more a combination and configuration of well-understood tech that has been around since the early 2000s.</p><p>Each of these steps has dedicated chapters, but it is helpful to understand them at a high level first. Since they depend on each other, it will help when explaining further the purpose of each of these steps.</p><h3 id=signaling-how-clients-find-each-other-in-webrtc>Signaling: How clients find each other in WebRTC
<a class=anchor href=#signaling-how-clients-find-each-other-in-webrtc>#</a></h3><p>When a WebRTC Agent starts it has no idea who it is going to communicate with and what they are going to communicate about. Signaling solves this issue! Signaling is used to bootstrap the call so that two WebRTC agents can start communicating.</p><p>Signaling uses an existing protocol SDP. SDP is a plain-text protocol. Each SDP message is made up of key/value pairs and contains a list of &lsquo;media sections&rsquo;. The SDP that the two WebRTC Agents exchange contains details like.</p><ul><li>IPs and Ports that the agent is reachable on (candidates)</li><li>How many audio and video tracks the agent wishes to send</li><li>What audio and video codecs the agent supports</li><li>Values used while connecting (uFrag/uPwd)</li><li>Values used while securing (certificate fingerprint)</li></ul><p>Note that signaling typically happens &ldquo;out-of-band&rdquo;; that is, applications generally don&rsquo;t use WebRTC itself to trade signaling messages. Any architecture suitable for sending messages can be used to relay the SDPs between the connecting peers, and many applications will use their existing infrastructure (like REST endpoints, websocket connections, or authentication proxies) to facilitate easy trading of SDPs between the proper clients.</p><h3 id=connecting-and-nat-traversal-with-stunturn>Connecting and NAT Traversal with STUN/TURN
<a class=anchor href=#connecting-and-nat-traversal-with-stunturn>#</a></h3><p>The two WebRTC Agents now know enough details to attempt to connect to each other. WebRTC then uses another established technology called ICE.</p><p>ICE (Interactive Connectivity Establishment) is a protocol that pre-dates WebRTC. ICE allows the establishment of a connection between two Agents. These Agents could be on the same network, or on the other side of the world. ICE is the solution to establishing a direct connection without a central server.</p><p>The real magic here is &lsquo;NAT Traversal&rsquo; and STUN/TURN Servers. These two concepts are all you need to communicate with an ICE Agent in another subnet. We will explore these topics in depth later.</p><p>Once ICE successfully connects, WebRTC then moves on to establishing an encrypted transport. This transport is used for audio, video, and data.</p><h3 id=securing-the-transport-layer-with-dtls-and-srtp>Securing the transport layer with DTLS and SRTP
<a class=anchor href=#securing-the-transport-layer-with-dtls-and-srtp>#</a></h3><p>Now that we have bi-directional communication (via ICE) we need to establish secure communication. This is done through two protocols that pre-date WebRTC. The first protocol is DTLS (Datagram Transport Layer Security) which is just TLS over UDP. TLS is the technology that powers HTTPS. The second protocol is SRTP (Secure Real-time Transport Protocol).</p><p>First, WebRTC connects by doing a DTLS handshake over the connection established by ICE. Unlike HTTPS, WebRTC doesn&rsquo;t use a central authority for certificates. Instead, WebRTC just asserts that the certificate exchanged via DTLS matches the fingerprint shared via signaling. This DTLS connection is then used for DataChannel messages.</p><p>WebRTC then uses a different protocol for audio/video transmission called RTP. We secure our RTP packets using SRTP. We initialize our SRTP session by extracting the keys from the negotiated DTLS session. In a later chapter, we discuss why media transmission has its own protocol.</p><p>We are done! You now have bi-directional and secure communication. If you have a stable connection between your WebRTC Agents this is all the complexity you may need. Unfortunately, the real world has packet loss and bandwidth limits, and the next section is about how we deal with them.</p><h3 id=communicating-with-peers-via-rtp-and-sctp>Communicating with peers via RTP and SCTP
<a class=anchor href=#communicating-with-peers-via-rtp-and-sctp>#</a></h3><p>We now have two WebRTC Agents with secure bi-directional communication. Let&rsquo;s start communicating! Again, we use two pre-existing protocols: RTP (Real-time Transport Protocol), and SCTP (Stream Control Transmission Protocol). SRTP is used to encrypt media exchanged over RTP, and SCTP is used to send DataChannel messages encrypted with DTLS.</p><p>RTP is quite minimal but provides what is needed to implement real-time streaming. The important thing is that RTP gives flexibility to the developer so they can handle latency, loss, and congestion as they please. We will discuss this further in the media chapter.</p><p>The final protocol in the stack is SCTP. SCTP allows many different delivery options for messages. You can optionally choose to have unreliable, out of order delivery so you can get the latency needed for real-time systems.</p><h2 id=webrtc-a-collection-of-protocols>WebRTC, a collection of protocols
<a class=anchor href=#webrtc-a-collection-of-protocols>#</a></h2><p>WebRTC solves a lot of problems. At first, this may even seem over-engineered. The genius of WebRTC is really the humility. It didn&rsquo;t assume it could solve everything better. Instead, it embraced many existing single purpose technologies and bundled them together.</p><p>This allows us to examine and learn each part individually without being overwhelmed. A good way to visualize it is a &lsquo;WebRTC Agent&rsquo; is really just an orchestrator of many different protocols.</p><script src=/mermaid.min.js></script><script>mermaid.initialize({"flowchart":{"useMaxWidth":true},"theme":"default"})</script><p class=mermaid>graph TB
webrtc{WebRTC Agent}
sctp{SCTP Agent}
dtls{DTLS Agent}
ice{ICE Agent}
stun{STUN Protocol}
turn{TURN Agent}
srtp{SRTP Agent}
sctp{SDP}
rtp{RTP}
rtcp{RTCP}
webrtc --> ice
webrtc --> dtls
webrtc --> sctp
webrtc --> srtp
ice --> turn
ice --> stun
srtp --> rtcp
srtp --> rtp</p><h2 id=how-does-webrtc-the-api-work>How does WebRTC (the API) work
<a class=anchor href=#how-does-webrtc-the-api-work>#</a></h2><p>This section shows how the Javascript API maps to the protocol. This isn&rsquo;t meant as an extensive demo of the WebRTC API, but more to create a mental model of how it all ties together.
If you aren&rsquo;t familiar with either, it is ok. This could be a fun section to return to as you learn more!</p><h4 id=new-peerconnection><code>new PeerConnection</code>
<a class=anchor href=#new-peerconnection>#</a></h4><p>The PeerConnection is the top-level &lsquo;WebRTC Session&rsquo;. It contains all the protocols mentioned above. The subsystems are all allocated but nothing happens yet.</p><h4 id=addtrack><code>addTrack</code>
<a class=anchor href=#addtrack>#</a></h4><p><code>addTrack</code> creates a new RTP stream. A random SSRC will be generated for this stream. This stream will then be inside the Session Description generated by <code>createOffer</code> inside a media section. Each call to <code>addTrack</code> will create a new SSRC and media section.</p><p>Immediately after a SRTP Session is established these media packets will start being sent via ICE after being encrypted using SRTP.</p><h4 id=createdatachannel><code>createDataChannel</code>
<a class=anchor href=#createdatachannel>#</a></h4><p><code>createDataChannel</code> creates a new SCTP stream if no SCTP association exists. By default, SCTP is not enabled but is only started when one side requests a data channel.</p><p>Immediately after a DTLS Session is established, the SCTP association will start sending packets via ICE and encrypted with DTLS.</p><h4 id=createoffer><code>createOffer</code>
<a class=anchor href=#createoffer>#</a></h4><p><code>createOffer</code> generates a Session Description of the local state to be shared with the remote peer.</p><p>The act of calling <code>createOffer</code> doesn&rsquo;t change anything for the local peer.</p><h4 id=setlocaldescription><code>setLocalDescription</code>
<a class=anchor href=#setlocaldescription>#</a></h4><p><code>setLocalDescription</code> commits any requested changes. <code>addTrack</code>, <code>createDataChannel</code> and similar calls are all temporary until this call. <code>setLocalDescription</code> is called with the value generated by <code>createOffer</code>.</p><p>Usually, after this call, you will send the offer to the remote peer, and they will call <code>setRemoteDescription</code> with it.</p><h4 id=setremotedescription><code>setRemoteDescription</code>
<a class=anchor href=#setremotedescription>#</a></h4><p><code>setRemoteDescription</code> is how we inform the local agent about the remote candidates&rsquo; state. This is how the act of &lsquo;Signaling&rsquo; is done with the Javascript API.</p><p>When <code>setRemoteDescription</code> has been called on both sides, the WebRTC Agents now have enough info to start communicating P2P!</p><h4 id=addicecandidate><code>addIceCandidate</code>
<a class=anchor href=#addicecandidate>#</a></h4><p><code>addIceCandidate</code> allows a WebRTC agent to add more remote ICE Candidates whenever they want. This API sends the ICE Candidate right into the ICE subsystem and has no other effect on the greater WebRTC connection.</p><h4 id=ontrack><code>ontrack</code>
<a class=anchor href=#ontrack>#</a></h4><p><code>ontrack</code> is a callback that is fired when a RTP packet is received from the remote peer. The incoming packets would have been declared in the Session Description that was passed to <code>setRemoteDescription</code></p><p>WebRTC uses the SSRC and looks up the associated MediaStream and MediaStreamTrack and fires this callback with these details populated.</p><h4 id=oniceconnectionstatechange><code>oniceconnectionstatechange</code>
<a class=anchor href=#oniceconnectionstatechange>#</a></h4><p><code>oniceconnectionstatechange</code> is a callback that is fired that reflects the state of the ICE Agent. When you have network connectivity or when you become disconnected this is how you are notified.</p><h4 id=onstatechange><code>onstatechange</code>
<a class=anchor href=#onstatechange>#</a></h4><p><code>onstatechange</code> is a combination of ICE Agent and DTLS Agent state. You can watch this to be notified when ICE and DTLS have both completed successfully.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li class=active><a href=https://webrtcforthecurious.com/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/01-what-why-and-how/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/229087f841056eddd08b1f74942deb2c5ef8bea7 title="Last modified by Alan Fregtman | September 19, 2020" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>September 19, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content//docs/01-what-why-and-how.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#why-should-i-learn-webrtc>Why should I learn WebRTC?</a></li><li><a href=#webrtc-protocol-is-a-collection-of-other-technologies>WebRTC Protocol is a collection of other technologies</a><ul><li><a href=#signaling-how-clients-find-each-other-in-webrtc>Signaling: How clients find each other in WebRTC</a></li><li><a href=#connecting-and-nat-traversal-with-stunturn>Connecting and NAT Traversal with STUN/TURN</a></li><li><a href=#securing-the-transport-layer-with-dtls-and-srtp>Securing the transport layer with DTLS and SRTP</a></li><li><a href=#communicating-with-peers-via-rtp-and-sctp>Communicating with peers via RTP and SCTP</a></li></ul></li><li><a href=#webrtc-a-collection-of-protocols>WebRTC, a collection of protocols</a></li><li><a href=#how-does-webrtc-the-api-work>How does WebRTC (the API) work</a><ul><li></li></ul></li></ul></nav></aside></main></body></html>